# learn-go-practice slice
### array 与 slice的区别
1. 表像上的区别
```
数组类型的值的长度是固定的，而切片类型的值是可变长的。

数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，[1]string和[2]string就是两个不同的数组类型。
而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素 数量的增长而增长，但不会随着元素数量的减少而减小。
```
2. 深层次的区别
```
切片的底层数据结构是数组，切片也可以被看作是对数组的某个连续片段的引用。切片类型是引用类型，而数组是值类型
```
### nil slice 与 empty slice的区别
```
两者在使用上的区别
nil slice可以用== nil判断，而empty slice不行，empty slice只是代表空列表，里面的cap与len=0,并不代表==nil

在前端返回的data数据中如约定列表不存在需要返回空列表，此时我们还需要额外的初始化data里面的slice
```
### 切片的容量与长度
```
使用make初始化切片时，默认的容量与长度一致，cap代表slice的底层数组的长度，len代表slice本身的长度

当使用array或切片作为基础截取生成一个新切片，则len = end - start, cap = 底层数组的长度 - start
```
### 切片扩容
```
发生扩容后，如超过底层数组的容量，会新建一个新的切片，引用的是新的底层数组

当原容量不够时，新的切片的容量会按照之前容量的2倍扩容
当原来的容量为1024后，新的切片容量会按1.25倍扩容
当容量一口气增加到原容量2倍以上,新容量以会当前容量为基础

以上只能确定切片的大致容量，还需要根据切片中的元素大小对齐内存

注：切片扩容未超过原先底层数组的容量时，并不会产生新的底层数组。
如扩容超过原先底层数组的容量，则会抛弃原先的底层数组，产生一个新的数组作为引用。此时再修改相关的值，并不会对之前的数组有影响
```
### 切片复制
```
copy复制为值复制，改变原切片的值不会影响新切片。而等号复制为指针复制，改变原切片或新切片都会对另一个产生影响。
```
### 切片作为参数传递
```
slice作参数传递时，虽然是值传递（拷贝一份），但是slice的内部指针，指向的还是同一个数组是引用，所以会有影响。
```